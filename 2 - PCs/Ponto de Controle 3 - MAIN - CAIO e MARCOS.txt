//Marcos Felippe dos Santos Vieira Alves Universidade de Brasília – Faculdade do Gama Estudante de Engenharia Eletrônica Brasília, Brasil mfelippe.bsb@hotmail.com 
//Caio Matheus Zardo Lopes Universidade de Brasília – Faculdade do Gama Estudante de Engenharia Eletrônica Brasília, Brasil                                caioozardoo@gmail.com

#include <msp430g2452.h>


#define IN1 BIT7
#define IN2 BIT6


int miliseconds;
int distance;
long sensor;

void main(void)
{
  BCSCTL1 = CALBC1_1MHZ;
  DCOCTL = CALDCO_1MHZ;                     // submainclock 1mhz
  WDTCTL = WDTPW + WDTHOLD;                 // Parando o  WDT

  CCTL0 = CCIE;                             // habilitando interrupção CCR0
  CCR0 = 1000;                              // 1ms ate 1mhz
  TACTL = TASSEL_2 + MC_1;                  // SMCLK, upmode

  P1IFG  = 0x00;                            //limpando todas as flags de interrupção
  P1DIR |= 0x01 + IN1 + IN2;                // habilitando as saidas
  P1OUT &= ~0x01 + ~IN1 + ~IN2;             // colocando as saidas em nivel logico baixo

  _BIS_SR(GIE);                             // ativando interrupção global

 while(1){
    P1IE &= ~0x01;                          // desabilitando interrupção
    P1DIR |= 0x02;                          // trigger no pino p1.2
    P1OUT |= 0x02;                          // gerando pulso
    __delay_cycles(10);                     //  10us
    P1OUT &= ~0x02;                         // parando o pulso

    P1DIR &= ~0x04;                         // ECHO
        P1IFG = 0x00;                       // limpando as flags por segurança
    P1IE |= 0x04;                           // habilitando interrupção  no ECHO
    P1IES &= ~0x04;                         // borda de descida
        __delay_cycles(30000);              // delay de 30ms
        distance = sensor/58;               //convertendo echo em CM
        if(distance < 20 && distance != 0) P1OUT |= 0x01 + IN1 + (~IN2);  // ativando os motores
        else P1OUT &= ~0x01 + ~IN1 + ~IN2;




 }
}

#pragma vector=PORT1_VECTOR
__interrupt void Port_1(void)
{
    if(P1IFG&0x04)                          //há interrupção pendente?
        {
          if(!(P1IES&0x04))                 //esta é a borda de subida?
          {
            TACTL|=TACLR;                   //limpar timer A
            miliseconds = 0;
            P1IES |= 0x04;                  //borda de descida
          }
          else
          {
            sensor = (long)miliseconds*1000 + (long)TAR;    //calculando comprimento ECHO 

          }
    P1IFG &= ~0x04;                         //limpar FG
    }
}

#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A (void)
{
  miliseconds++;
}



